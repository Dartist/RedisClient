        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>RedisClient class / redis_client Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="redis_client" data-type="RedisClient">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../redis_client.html">redis_client</a> &rsaquo; <a href="../redis_client/RedisClient.html">RedisClient</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>RedisClient</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>The <a class="crossref" href="../redis_client/RedisClient.html">RedisClient</a> is a high level class to access your redis server.</p>
<p>You create a <a class="crossref" href="../redis_client/RedisClient.html">RedisClient</a> like this:</p>
<pre><code>var connectionString = "localhost:6379";
RedisClient.connect(connectionString)
    .then((RedisClient client) {
      // Use your client here. Eg.:
      client.set("test", "value").then((_) =&gt; print("success"));
    });
</code></pre>
<p><a class="crossref" href="../redis_client/RedisClient.html">RedisClient</a> creates a <a class="crossref" href="../redis_client/RedisConnection.html">RedisConnection</a> internally, and just forwards the
<code>connectionString</code> to it. So please refer to the <a class="crossref" href="../redis_client/RedisConnection.html">RedisConnection</a>
doc for a list of valid connection strings.</p>
<p>If you need to access the lower level functions for some reason, you can
access the <code>RawRedisCommands</code> with <code>RedisClient.raw</code>.</p>
<p>To see how the binary redis socket works and detailed list of available
commands, please visit <a href="http://redis.io/commands">redis documentation</a>.</p>
<pre class="source">
class RedisClient {

 String connectionString;

 /// The [RedisConnection] used to communicate with the Redis server.
 RedisConnection connection;

 /// The future that gets resolved as soon as the connection is available.
 Future&lt;RedisConnection&gt; connectionFuture;


 /// Used to serialize and deserialize the values stored inside Redis.
 RedisSerializer serializer = new RedisSerializer();




 /// Returns a [Future] for a [RedisClient].
 static Future&lt;RedisClient&gt; connect([ String connectionString ]) {
   var redisClient = new RedisClient._(connectionString);
   return redisClient.connectionFuture.then((_) =&gt; redisClient);
 }


 /// Creates the [RedisConnection] and an instance of [RawRedisCommands].
 RedisClient._(String this.connectionString) {
   connectionFuture = RedisConnection.connect(connectionString)
       .then((conn) =&gt; connection = conn);
 }






 /// Converts bytes to a Map
 Map&lt;String,Object&gt; toMap(List&lt;List&lt;int&gt;&gt; multiData) {
   Map&lt;String,Object&gt; map = new Map&lt;String,Object&gt;();
   for (int i = 0; i &lt; multiData.length; i += 2) {
     String key = _toStr(multiData[i]);
     map[key] = serializer.deserialize(multiData[i + 1]);
   }
   return map;
 }


 Map&lt;Object,double&gt; toScoreMap(List&lt;List&lt;int&gt;&gt; multiData) {
   Map&lt;Object,double&gt; map = new Map&lt;String,double&gt;();
   for (int i = 0; i &lt; multiData.length; i += 2) {
     Object key = serializer.deserialize(multiData[i]);
     map[key] = double.parse(_toStr(multiData[i + 1]));
   }
   return map;
 }

 /// Converts a list of bytes to a string
 static String _toStr(List&lt;int&gt; bytes) =&gt; bytes == null ? null : new String.fromCharCodes(bytes);


 /// Converts a String to a list of UTF8 bytes.
 static List&lt;int&gt; _keyBytes(String key) {
   if (key == null || key.isEmpty) throw new Exception("Key can not be null.");
   return encodeUtf8(key);
 }

 /// Converts any given value to it's binary representation of the string.
 static List&lt;int&gt; _toBytes(Object value) {
   if (value == null) return new List&lt;int&gt;();
   else return encodeUtf8(value.toString());
 }

 /// Converts an integer to it's binary string representation.
 static List&lt;int&gt; _intToBytes(int value) {
   if (value == null) throw new Exception("Integer can not be null.");
   return encodeUtf8(value.toString());
 }

 /// Takes a command and a map and returns a list of all binary values.
 List&lt;List&lt;int&gt;&gt; _keyValueMapToList(List&lt;int&gt; command, Map map) {

   List&lt;List&lt;int&gt;&gt; completeList = new List&lt;List&lt;int&gt;&gt;(map.length * 2 + 1);
   completeList[0] = command;

   var i = 1;
   map.forEach((key, value) {
     completeList[i++] = _keyBytes(key);
     completeList[i++] = serializer.serialize(value);
   });

   return completeList;
 }



 /// Wrapper for [RedisConnection.db]
 int get db =&gt; connection.db;

 Map get stats =&gt; connection.stats;

 Future close() =&gt; connection.close();



 /// Admin
 /// =====


 /// Select a database.
 ///
 /// Wrapper for [RedisConnection.select]
 Future select(int db) =&gt; connection.select(db);

 /// Return the number of keys in the currently-selected database.
 Future&lt;int&gt; get dbsize =&gt; connection.rawSend([ RedisCommand.DBSIZE ]).receiveInteger();

 /// Delete all the keys of the currently selected DB. This command never fails
 Future flushdb() =&gt; connection.rawSend([ RedisCommand.FLUSHDB ]).receiveStatus("OK");

 /// Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.
 Future flushall() =&gt; connection.rawSend([ RedisCommand.FLUSHALL ]).receiveStatus("OK");


 /// Returns the DateTime of the last DB [save] executed with success.
 Future&lt;DateTime&gt; get lastsave =&gt; connection.rawSend([ RedisCommand.LASTSAVE ]).receiveInteger().then((int unixTs) =&gt; new DateTime.fromMillisecondsSinceEpoch(unixTs * 1000, isUtc: true));

 /**
  * The [save] command performs a synchronous save of the dataset producing a point
  * in time snapshot of all the data inside the Redis instance, in the form of an RDB file.
  *
  * You almost never want to call [save] in production environments where it will
  * block all the other clients. Instead usually [bgsave] is used. However in case
  * of issues preventing Redis to create the background saving child (for instance
  * errors in the fork(2) system call), the [save] command can be a good last resort
  * to perform the dump of the latest dataset.
  */
 Future save() =&gt; connection.rawSend([ RedisCommand.SAVE ]).receiveStatus("OK");

 /**
  * Save the DB in background. The OK code is immediately returned.
  *
  * Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits.
  *
  * A client my be able to check if the operation succeeded using the [lastsave] command.
  */
 Future bgsave() =&gt; connection.rawSend([ RedisCommand.BGSAVE ]).receiveStatus("Background saving started");

 /**
  * The command behavior is the following:
  *
  * - Stop all the clients.
  * - Perform a blocking SAVE if at least one **save point** is configured.
  * - Flush the Append Only File if AOF is enabled.
  * - Quit the server.
  *
  * If persistence is enabled this commands makes sure that Redis is switched off
  * without the lost of any data. This is not guaranteed if the client uses simply
  * SAVE and then QUIT because other clients may alter the DB data between the two commands.
  *
  * Note: A Redis instance that is configured for not persisting on disk (no AOF
  * configured, nor "save" directive) will not dump the RDB file on SHUTDOWN,
  * as usually you don't want Redis instances used only for caching to block on
  * when shutting down.
  */
 Future shutdown() =&gt; connection.rawSend([ RedisCommand.SHUTDOWN ]).receive();

 /**
  * Instruct Redis to start an Append Only File rewrite process. The rewrite will
  * create a small optimized version of the current Append Only File.
  *
  * If BGREWRITEAOF fails, no data gets lost as the old AOF will be untouched.
  *
  * The rewrite will be only triggered by Redis if there is not already a background
  * process doing persistence.
  */
 Future bgrewriteaof() =&gt; connection.rawSend([ RedisCommand.BGREWRITEAOF ]).receiveStatus("OK");

 /**
  * Ask the server to close the connection.
  *
  * The connection is closed as soon as all pending replies have been written to the client.
  */
 Future quit() =&gt; connection.rawSend([ RedisCommand.QUIT ]).receiveStatus("OK");

 /**
  * The INFO command returns information and statistics about the server.
  *
  * This function parses the output properly and returns a map in the form of:
  *
  *     {
  *       "Server": {
  *           "redis_version": "2.5.13",
  *           "redis_git_sha1": "2812b945"
  *           /* etc... */
  *       },
  *       "Clients": {
  *           "connected_clients": "8"
  *           /* etc... */
  *       }
  *       /* etc... */
  *     }
  *
  * Please refer to the [official redis info documentation](http://redis.io/commands/info)
  * for an explanation of the values.
  */
 Future&lt;Map&lt;String, Map&lt;String, String&gt;&gt;&gt; get info {
   return connection.rawSend([ RedisCommand.INFO ]).receiveBulkString().then(parseInfoString);
 }

 /**
  * Parses the string returned by the INFO command.
  */
 Map&lt;String, Map&lt;String, String&gt;&gt; parseInfoString(String lines) {
   Map&lt;String, Map&lt;String, String&gt;&gt; info = { };

   var sectionMap, sectionName;

   for (String line in lines.split(new RegExp(r"(\r\n|\n)"))) {
     if (line.isEmpty) continue;

     if (line.substring(0, 2) == '# ') {
       // New section
       sectionName = line.substring(2);
       sectionMap = new Map&lt;String, String&gt;();
       info[sectionName] = sectionMap;
     }
     else {
       if (sectionMap == null) throw new RedisClientException("Received an info line ($line) without a section.");

       // Section info
       var colonIndex = line.indexOf(":");
       if (colonIndex &lt; 1) throw new RedisClientException("The info line did not contain a colon (:).");

       sectionMap[line.substring(0, colonIndex)] = line.substring(colonIndex + 1);
     }
   }

   return info;
 }

 /**
  * This command is often used to test if a connection is still alive, or to measure latency.
  *
  * Fails if the result is not PONG.
  */
 Future&lt;String&gt; ping() =&gt; connection.rawSend([ RedisCommand.PING ]).receiveStatus("PONG");

 /// Returns message.
 Future&lt;Object&gt; echo(Object value) =&gt; connection.rawSend([ RedisCommand.ECHO, serializer.serialize(value) ]).receiveBulkData().then(serializer.deserialize);

 /**
  * Returns the string representation of the type of the value stored at key.
  *
  * The different types that can be returned are:
  *
  * - string
  * - list
  * - set
  * - zset
  * - hash
  * - none if string didn't exist
  */
 Future&lt;String&gt; type(String key) =&gt; connection.rawSend([ RedisCommand.TYPE, _keyBytes(key) ]).receiveStatus();


 /// Keys
 /// ====


 /**
  * Returns all keys matching pattern.
  *
  * While the time complexity for this operation is O(N), the constant times are fairly low. For example, Redis running on an entry level laptop can scan a 1 million key database in 40 milliseconds.
  *
  * Supported glob-style patterns:
  *
  * - `h?llo` matches `hello`, `hallo` and `hxllo`
  * - `h*llo` matches `hllo` and `heeeello`
  * - `h[ae]llo` matches `hello` and `hallo`, but not `hillo`
  *
  * Use `\` to escape special characters if you want to match them verbatim.
  *
  * **Warning**: consider [keys] as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don't use [keys] in your regular application code. If you're looking for a way to find keys in a subset of your keyspace, consider using sets.
  */
 Future&lt;List&lt;String&gt;&gt; keys(String pattern) =&gt; connection.rawSend([ RedisCommand.KEYS, _keyBytes(pattern) ]).receiveMultiBulkStrings();

 /// Returns the stored value of given key.
 Future&lt;Object&gt; get(String key) =&gt; connection.rawSend([ RedisCommand.GET, _keyBytes(key) ]).receiveBulkDeserialized(serializer);

 /// Returns all the stored values of given keys.
 Future&lt;List&lt;Object&gt;&gt; mget(List&lt;String&gt; keys) =&gt; keys.isEmpty ? new Future.value([ ]) : connection.rawSend(_CommandUtils.mergeCommandWithStringArgs(RedisCommand.MGET, keys)).receiveMultiBulkDeserialized(serializer);

 /// Sets the value of given key, and returns the value that was stored previously.
 Future&lt;Object&gt; getset(String key, Object value) =&gt; connection.rawSend([RedisCommand.GETSET, _keyBytes(key), serializer.serialize(value)]).receiveBulkData().then(serializer.deserialize);

 /// Sets the value of given key.
 Future set(String key, Object value) =&gt; connection.rawSend([ RedisCommand.SET, _keyBytes(key), serializer.serialize(value) ]).receiveStatus("OK");

 /**
  * Sets a value and the expiration in one step.
  *
  * This is the same as:
  *
  *     client
  *         ..set(mykey, value)
  *         ..expire(mykey, seconds);
  */
 Future setex(String key, int expireInSecs, Object value) =&gt; connection.rawSend([ RedisCommand.SETEX, _keyBytes(key), _intToBytes(expireInSecs), serializer.serialize(value) ]).receiveStatus("OK");

 /// [psetex] works exactly like [setex] with the sole difference that the expire time is specified in milliseconds instead of seconds.
 Future psetex(String key, int expireInMs, Object value) =&gt; connection.rawSend([ RedisCommand.PSETEX, _keyBytes(key), _intToBytes(expireInMs), serializer.serialize(value) ]).receiveStatus("OK");

 /**
  * Remove the existing timeout on key.
  *
  * Turns the key from volatile (a key with an expire set) to persistent (a key that will never expire as no timeout is associated).
  *
  * Returns `true` if the timeout was removed, `0` if key does not exist or does not have an associated timeout.
  */
 Future&lt;bool&gt; persist(String key) =&gt; connection.rawSend([ RedisCommand.PERSIST, _keyBytes(key) ]).receiveBool();

 /**
  * Sets all values in the given map.
  *
  * [mset] replaces existing values with new values, just as regular [set].
  *
  * See [msetnx] if you don't want to overwrite existing values.
  */
 Future mset(Map map) =&gt; connection.rawSend(_keyValueMapToList(RedisCommand.MSET, map)).receiveStatus("OK");

 /**
  * Sets the given keys to their respective values. **[msetnx] will not perform any operation at all even if just a single key already exists.**
  *
  * Because of this semantic [msetnx] can be used in order to set different keys representing different fields of an unique logic object in a way that ensures that either all the fields or none at all are set.
  *
  * [msetnx] is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.
  */
 Future&lt;bool&gt; msetnx(Map map) =&gt; connection.rawSend(_keyValueMapToList(RedisCommand.MSETNX, map)).receiveBool();

 /// Returns `true` if key exists, `false` otherwise.
 Future&lt;bool&gt; exists(String key) =&gt; connection.rawSend([ RedisCommand.EXISTS, _keyBytes(key) ]).receiveBool();

 /**
  * Deletes a single key.
  *
  * Returns true if the key existed, false otherwise.
  *
  * Contrary to redis `DEL` command this method takes only one key for
  * convenience. Use [mdel] if you want to delete multiple keys.
  */
 Future&lt;bool&gt; del(String key) =&gt; mdel([ key ]).then((deleteCount) =&gt; deleteCount == 1);

 /**
  * Deletes multiple keys and returns the number of deleted keys.
  *
  * This command is called `DEL` in redis.
  */
 Future&lt;int&gt; mdel(List&lt;String&gt; keys) =&gt; keys.isEmpty ? new Future.value(0) : connection.rawSend(_CommandUtils.mergeCommandWithStringArgs(RedisCommand.DEL, keys)).receiveInteger();

 /**
  * Increments the number stored at key by one returning the value of key after
  * the increment.
  *
  * If the key does not exist, it is set to 0 before performing the operation.
  *
  * An error is returned if the key contains a value of the wrong type or
  * contains a string that can not be represented as integer.
  *
  * This operation is limited to 64 bit signed integers.
  */
 Future&lt;int&gt; incr(String key) =&gt; connection.rawSend([ RedisCommand.INCR, _keyBytes(key) ]).receiveInteger();

 /**
  * Increments the number stored at key by increment and returns the value after
  * the increment.
  *
  * If the key does not exist, it is set to 0 before performing the operation.
  *
  * An error is returned if the key contains a value of the wrong type or
  * contains a string that can not be represented as integer.
  *
  * This operation is limited to 64 bit signed integers.
  */
  Future&lt;int&gt; incrby(String key, int count) =&gt; connection.rawSend([ RedisCommand.INCRBY, _keyBytes(key), serializer.serialize(count) ]).receiveInteger();
//
//  Future&lt;double&gt; incrbyfloat(String key, double count) =&gt; connection.sendExpectDouble([RedisCommand.INCRBYFLOAT, _keyBytes(key), serializer.serialize(count)]);
//
//  Future&lt;int&gt; decr(String key) =&gt; connection.sendExpectInt([RedisCommand.DECR, _keyBytes(key)]);
//
//  Future&lt;int&gt; decrby(String key, int count) =&gt; connection.sendExpectInt([RedisCommand.DECRBY, _keyBytes(key), serializer.serialize(count)]);
//
//  Future&lt;int&gt; strlen(String key) =&gt; connection.sendExpectInt([RedisCommand.STRLEN, _keyBytes(key)]);
//
//  /// Wrapper for [RawRedisCommands.append].
//  Future&lt;int&gt; append(String key, String value) =&gt; raw.append(key, serializer.serialize(value));
//
//
//  /// Wrapper for [RawRedisCommands.substr].
//  Future&lt;String&gt; substr(String key, int fromIndex, int toIndex) =&gt; raw.substr(key, fromIndex, toIndex).then(_toStr);
//
//  /// Wrapper for [RawRedisCommands.getrange].
//  Future&lt;String&gt; getrange(String key, int fromIndex, int toIndex) =&gt; raw.getrange(key, fromIndex, toIndex).then(_toStr);
//
//  /// Wrapper for [RawRedisCommands.setrange].
//  Future&lt;String&gt; setrange(String key, int offset, String value) =&gt; raw.setrange(key, offset, serializer.serialize(value)).then(_toStr);
//
//  Future&lt;int&gt; getbit(String key, int offset) =&gt; connection.sendExpectInt([RedisCommand.GETBIT, _keyBytes(key), serializer.serialize(offset)]);
//
//  Future&lt;int&gt; setbit(String key, int offset, int value) =&gt; connection.sendExpectInt([RedisCommand.SETBIT, _keyBytes(key), serializer.serialize(offset), serializer.serialize(value)]);
//
//  /// Wrapper for [RawRedisCommands.randomkey].
//  Future&lt;String&gt; randomkey() =&gt; raw.randomkey().then(_toStr);
//
//  Future rename(String oldKey, String newKey) =&gt; connection.sendExpectSuccess([RedisCommand.RENAME, _keyBytes(oldKey), _keyBytes(newKey)]);
//
//  Future&lt;bool&gt; renamenx(String oldKey, String newKey) =&gt; connection.sendExpectIntSuccess([RedisCommand.RENAMENX, _keyBytes(oldKey), _keyBytes(newKey)]);
//
//  Future&lt;bool&gt; expire(String key, int expireInSecs) =&gt; connection.sendExpectIntSuccess([RedisCommand.EXPIRE, _keyBytes(key), serializer.serialize(expireInSecs)]);
//
//  Future&lt;bool&gt; pexpire(String key, int expireInMs) =&gt; connection.sendExpectIntSuccess([RedisCommand.PEXPIRE, _keyBytes(key), serializer.serialize(expireInMs)]);
//
//  /// Wrapper for [RawRedisCommands.expireat].
//  Future&lt;bool&gt; expireat(String key, DateTime date) =&gt; raw.expireat(key, date.toUtc().millisecondsSinceEpoch ~/ 1000);
//
//  /// Wrapper for [RawRedisCommands.pexpireat].
//  Future&lt;bool&gt; pexpireat(String key, DateTime date) =&gt; raw.pexpireat(key, date.toUtc().millisecondsSinceEpoch);

 /**
  * Returns the remaining time to live of a key that has a timeout.
  *
  * This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.
  */
 Future&lt;int&gt; ttl(String key) =&gt; connection.rawSend([ RedisCommand.TTL, _keyBytes(key) ]).receiveInteger();

//  Future&lt;int&gt; pttl(String key) =&gt; connection.sendExpectInt([RedisCommand.PTTL, _keyBytes(key)]);
//
//
//
//  /// SET
//  /// ===
//
//  /// Wrapper for [RawRedisCommands.smembers].
//  Future&lt;List&lt;Object&gt;&gt; smembers(String setId) =&gt; raw.smembers(setId).then((x) =&gt; x.map(serializer.deserialize));
//
//  /// Wrapper for [RawRedisCommands.sadd].
//  Future&lt;int&gt; sadd(String setId, Object value) =&gt; raw.sadd(setId, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.smadd].
//  Future&lt;int&gt; smadd(String setId, List&lt;Object&gt; values) =&gt; raw.smadd(setId, values.map((x) =&gt; serializer.serialize(x)));
//
//  /// Wrapper for [RawRedisCommands.srem].
//  Future&lt;int&gt; srem(String setId, Object value) =&gt; raw.srem(setId, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.spop].
//  Future&lt;Object&gt; spop(String setId) =&gt; raw.spop(setId).then(serializer.deserialize);
//
//  /// Wrapper for [RawRedisCommands.smove].
//  Future&lt;bool&gt; smove(String fromSetId, String toSetId, Object value) =&gt; raw.smove(fromSetId, toSetId, serializer.serialize(value));
//
//  Future&lt;int&gt; scard(String setId) =&gt; connection.sendExpectInt([RedisCommand.SCARD, _keyBytes(setId)]);
//
//  /// Wrapper for [RawRedisCommands.sismember].
//  Future&lt;bool&gt; sismember(String setId, Object value) =&gt; raw.sismember(setId, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.sinter].
//  Future&lt;List&lt;Object&gt;&gt; sinter(List&lt;String&gt; setIds) =&gt; raw.sinter(setIds).then((x) =&gt; x.map(serializer.deserialize));
//
//  /// Wrapper for [RawRedisCommands.sinterstore].
//  Future&lt;int&gt; sinterstore(String intoSetId, List&lt;String&gt; setIds) =&gt; raw.sinterstore(intoSetId, setIds);
//
//  /// Wrapper for [RawRedisCommands.sunion].
//  Future&lt;List&lt;Object&gt;&gt; sunion(List&lt;String&gt; setIds) =&gt; raw.sunion(setIds).then((x) =&gt; x.map(serializer.deserialize));
//
//  Future&lt;int&gt; sunionstore(String intoSetId, List&lt;String&gt; setIds) =&gt;
//      connection.sendExpectInt(_CommandUtils.mergeCommandWithStringArgs(RedisCommand.SUNIONSTORE, $(setIds).insert(0, intoSetId)));
//
//  /// Wrapper for [RawRedisCommands.sdiff].
//  Future&lt;List&lt;Object&gt;&gt; sdiff(String fromSetId, List&lt;String&gt; withSetIds) =&gt; raw.sdiff(fromSetId, withSetIds).then((x) =&gt; x.map(serializer.deserialize));
//
//  Future&lt;int&gt; sdiffstore(String intoSetId, String fromSetId, List&lt;String&gt; withSetIds) {
//    withSetIds.insert(0, fromSetId);
//    withSetIds.insert(0, intoSetId);
//    return connection.sendExpectInt(_CommandUtils.mergeCommandWithStringArgs(RedisCommand.SDIFFSTORE, withSetIds));
//  }
//
//  /// Wrapper for [RawRedisCommands.srandmember].
//  Future&lt;Object&gt; srandmember(String setId) =&gt; raw.srandmember(setId).then(serializer.deserialize);
//
//
//
//
//  /// SORT SET/LIST
//  /// =============
//
//  Future&lt;List&lt;List&lt;int&gt;&gt;&gt; sort(String listOrSetId,
//    [String sortPattern, int skip, int take, String getPattern, bool sortAlpha=false, bool sortDesc=false, String storeAtKey]) {
//
//    List&lt;List&lt;int&gt;&gt; cmdWithArgs = [RedisCommand.SORT, _keyBytes(listOrSetId)];
//
//    if (sortPattern != null) {
//      cmdWithArgs.add(RedisCommand.BY);
//      cmdWithArgs.add(serializer.serialize(sortPattern));
//    }
//
//    if (skip != null || take != null) {
//      cmdWithArgs.add(RedisCommand.LIMIT);
//      cmdWithArgs.add(serializer.serialize(skip == null ? 0 : skip));
//      cmdWithArgs.add(serializer.serialize(take == null ? 0 : take));
//    }
//
//    if (getPattern != null) {
//      cmdWithArgs.add(RedisCommand.GET);
//      cmdWithArgs.add(serializer.serialize(getPattern));
//    }
//
//    if (sortDesc) cmdWithArgs.add(RedisCommand.DESC);
//
//    if (sortAlpha) cmdWithArgs.add(RedisCommand.ALPHA);
//
//    if (storeAtKey != null) {
//      cmdWithArgs.add(RedisCommand.STORE);
//      cmdWithArgs.add(serializer.serialize(storeAtKey));
//    }
//
//    return connection.sendExpectMultiData(cmdWithArgs);
//  }
//
//  //LIST
//
//
//  /// Wrapper for [RawRedisCommands.lrange].
//  Future&lt;List&lt;Object&gt;&gt; lrange(String listId, [int startingFrom=0, int endingAt=-1]) =&gt; raw.lrange(listId, startingFrom, endingAt).then((x) =&gt; x.map(serializer.deserialize));
//
//  /// Wrapper for [RawRedisCommands.lpush].
//  Future&lt;int&gt; lpush(String listId, Object value) =&gt; raw.lpush(listId, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.mlpush].
//  Future&lt;int&gt; mlpush(String listId, List&lt;Object&gt; values) =&gt; raw.mlpush(listId, values.map((x) =&gt; serializer.serialize(x)));
//
//  /// Wrapper for [RawRedisCommands.lpushx].
//  Future&lt;int&gt; lpushx(String listId, Object value) =&gt; raw.lpushx(listId, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.mlpushx].
//  Future&lt;int&gt; mlpushx(String listId, List&lt;Object&gt; values) =&gt; raw.mlpushx(listId, values.map((x) =&gt; serializer.serialize(x)));
//
//  /// Wrapper for [RawRedisCommands.rpush].
//  Future&lt;int&gt; rpush(String listId, Object value) =&gt; raw.rpush(listId, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.mrpush].
//  Future&lt;int&gt; mrpush(String listId, List&lt;Object&gt; values) =&gt; raw.mrpush(listId, values.map((x) =&gt; serializer.serialize(x)));
//
//  /// Wrapper for [RawRedisCommands.rpushx].
//  Future&lt;int&gt; rpushx(String listId, Object value) =&gt; raw.rpushx(listId, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.mrpushx].
//  Future&lt;int&gt; mrpushx(String listId, List&lt;Object&gt; values) =&gt; raw.mrpushx(listId, values.map((x) =&gt; serializer.serialize(x)));
//
//  Future ltrim(String listId, int keepStartingFrom, int keepEndingAt) =&gt; connection.sendExpectSuccess([RedisCommand.LTRIM, _keyBytes(listId), serializer.serialize(keepStartingFrom), serializer.serialize(keepEndingAt)]);
//
//  /// Wrapper for [RawRedisCommands.lrem].
//  Future&lt;int&gt; lrem(String listId, int removeNoOfMatches, Object value) =&gt; raw.lrem(listId, removeNoOfMatches, serializer.serialize(value));
//
//  Future&lt;int&gt; llen(String listId) =&gt; connection.sendExpectInt([RedisCommand.LLEN, _keyBytes(listId)]);
//
//  /// Wrapper for [RawRedisCommands.lindex].
//  Future&lt;Object&gt; lindex(String listId, int listIndex) =&gt; raw.lindex(listId, listIndex).then(serializer.deserialize);
//
//  /// Wrapper for [RawRedisCommands.lset].
//  Future lset(String listId, int listIndex, Object value) =&gt; raw.lset(listId, listIndex, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.lpop].
//  Future&lt;Object&gt; lpop(String listId) =&gt; raw.lpop(listId).then(serializer.deserialize);
//
//  /// Wrapper for [RawRedisCommands.rpop].
//  Future&lt;Object&gt; rpop(String listId) =&gt; raw.rpop(listId).then(serializer.deserialize);
//
//  /// Wrapper for [RawRedisCommands.rpoplpush].
//  Future&lt;Object&gt; rpoplpush(String fromListId, String toListId) =&gt; raw.rpoplpush(fromListId, toListId).then(serializer.deserialize);
//
//
//
//  /// SORTED SETS
//  /// ===========
//
//
//  /// Wrapper for [RawRedisCommands.zadd].
//  Future&lt;int&gt; zadd(String setId, num score, Object value) =&gt; raw.zadd(setId, score, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.zmadd].
//  Future&lt;int&gt; zmadd(String setId, Map&lt;Object,num&gt; scoresMap) {
//    List&lt;List&lt;int&gt;&gt; args = new List&lt;List&lt;int&gt;&gt;();
//    scoresMap.forEach((k,v) {
//      args.add(serializer.serialize(v));
//      args.add(serializer.serialize(k));
//    });
//    return raw.zmadd(setId, args);
//  }
//
//  /// Wrapper for [RawRedisCommands.zrem].
//  Future&lt;int&gt; zrem(String setId, Object value) =&gt; raw.zrem(setId, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.zmrem].
//  Future&lt;int&gt; zmrem(String setId, List&lt;Object&gt; values) =&gt; raw.zmrem(setId, values.map((x) =&gt; serializer.serialize(x)));
//
//  /// Wrapper for [RawRedisCommands.zincrby].
//  Future&lt;double&gt; zincrby(String setId, num incrBy, Object value) =&gt; raw.zincrby(setId, incrBy, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.zrank].
//  Future&lt;int&gt; zrank(String setId, Object value) =&gt; raw.zrank(setId, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.zrevrank].
//  Future&lt;int&gt; zrevrank(String setId, Object value) =&gt; raw.zrevrank(setId, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.zrange].
//  Future&lt;List&lt;Object&gt;&gt; zrange(String setId, int min, int max) =&gt; raw.zrange(setId, min, max).then((x) =&gt; x.map(serializer.deserialize));
//
//  /// Wrapper for [RawRedisCommands.zrangeWithScores].
//  Future&lt;Map&lt;Object,double&gt;&gt; zrangeWithScores(String setId, int min, int max) =&gt; raw.zrangeWithScores(setId, min, max).then(toScoreMap);
//
//  /// Wrapper for [RawRedisCommands.zrevrange].
//  Future&lt;List&lt;Object&gt;&gt; zrevrange(String setId, int min, int max) =&gt; raw.zrevrange(setId, min, max).then((x) =&gt; x.map(serializer.deserialize));
//
//  /// Wrapper for [RawRedisCommands.zrevrangeWithScores].
//  Future&lt;Map&lt;Object,double&gt;&gt; zrevrangeWithScores(String setId, int min, int max) =&gt; raw.zrevrangeWithScores(setId, min, max).then(toScoreMap);
//
//  /// Wrapper for [RawRedisCommands.zrangebyscore].
//  Future&lt;List&lt;Object&gt;&gt; zrangebyscore(String setId, num min, num max, [int skip, int take]) =&gt; raw.zrangebyscore(setId, min, max, skip, take).then((x) =&gt; x.map(serializer.deserialize));
//
//  /// Wrapper for [RawRedisCommands.zrangebyscoreWithScores].
//  Future&lt;Map&lt;Object,double&gt;&gt; zrangebyscoreWithScores(String setId, num min, num max, [int skip, int take]) =&gt; raw.zrangebyscoreWithScores(setId, min, max, skip, take).then(toScoreMap);
//
//  /// Wrapper for [RawRedisCommands.zrevrangebyscore].
//  Future&lt;List&lt;List&lt;int&gt;&gt;&gt; zrevrangebyscore(String setId, num min, num max, [int skip, int take]) =&gt; raw.zrevrangebyscore(setId, min, max, skip, take);
//
//  /// Wrapper for [RawRedisCommands.zrevrangebyscoreWithScores].
//  Future&lt;List&lt;List&lt;int&gt;&gt;&gt; zrevrangebyscoreWithScores(String setId, num min, num max, [int skip, int take]) =&gt; raw.zrevrangebyscoreWithScores(setId, min, max, skip, take);
//
//  Future&lt;int&gt; zremrangebyrank(String setId, int min, int max) =&gt; connection.sendExpectInt([RedisCommand.ZREMRANGEBYRANK, _keyBytes(setId), serializer.serialize(min), serializer.serialize(max)]);
//
//  Future&lt;int&gt; zremrangebyscore(String setId, num min, num max) =&gt; connection.sendExpectInt([RedisCommand.ZREMRANGEBYSCORE, _keyBytes(setId), serializer.serialize(min), serializer.serialize(max)]);
//
//  Future&lt;int&gt; zcard(String setId) =&gt; connection.sendExpectInt([RedisCommand.ZCARD, _keyBytes(setId)]);
//
//  /// Wrapper for [RawRedisCommands.zscore].
//  Future&lt;double&gt; zscore(String setId, Object value) =&gt; raw.zscore(setId, serializer.serialize(value));
//
//  Future&lt;int&gt; zunionstore(String intoSetId, List&lt;String&gt; setIds) {
//    setIds.insert(0, setIds.length.toString());
//    setIds.insert(0, intoSetId);
//    return connection.sendExpectInt(_CommandUtils.mergeCommandWithStringArgs(RedisCommand.ZUNIONSTORE, setIds));
//  }
//
//  Future&lt;int&gt; zinterstore(String intoSetId, List&lt;String&gt; setIds) {
//    setIds.insert(0, setIds.length.toString());
//    setIds.insert(0, intoSetId);
//    return connection.sendExpectInt(_CommandUtils.mergeCommandWithStringArgs(RedisCommand.ZINTERSTORE, setIds));
//  }
//
//
//
//
//  /// HASH
//  /// ====
//
//
//  /// Wrapper for [RawRedisCommands.hset].
//  Future&lt;bool&gt; hset(String hashId, String key, Object value) =&gt; raw.hset(hashId, key, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.hsetnx].
//  Future&lt;bool&gt; hsetnx(String hashId, String key, Object value) =&gt; raw.hsetnx(hashId, key, serializer.serialize(value));
//
//  /// Wrapper for [RawRedisCommands.hmset].
//  Future hmset(String hashId, Map&lt;String,Object&gt; map) =&gt; raw.hmset(hashId, map.keys.map(serializer.serialize), map.values.map(serializer.serialize));
//
//  Future&lt;int&gt; hincrby(String hashId, String key, int incrBy) =&gt; connection.sendExpectInt([RedisCommand.HINCRBY, _keyBytes(hashId), _keyBytes(key), serializer.serialize(incrBy)]);
//
//  Future&lt;double&gt; hincrbyfloat(String hashId, String key, double incrBy) =&gt; connection.sendExpectDouble([RedisCommand.HINCRBYFLOAT, _keyBytes(hashId), _keyBytes(key), serializer.serialize(incrBy)]);
//
//  /// Wrapper for [RawRedisCommands.hget].
//  Future&lt;Object&gt; hget(String hashId, String key) =&gt; raw.hget(hashId, key).then(serializer.deserialize);
//
//  /// Wrapper for [RawRedisCommands.hmget].
//  Future&lt;List&lt;Object&gt;&gt; hmget(String hashId, List&lt;String&gt; keys) =&gt; raw.hmget(hashId, keys).then((x) =&gt; x.map(serializer.deserialize));
//
//  Future&lt;int&gt; hdel(String hashId, String key) =&gt; connection.sendExpectInt([RedisCommand.HDEL, _keyBytes(hashId), _keyBytes(key)]);
//
//  Future&lt;bool&gt; hexists(String hashId, String key) =&gt; connection.sendExpectIntSuccess([RedisCommand.HEXISTS, _keyBytes(hashId), _keyBytes(key)]);
//
//  Future&lt;int&gt; hlen(String hashId) =&gt; connection.sendExpectInt([RedisCommand.HLEN, _keyBytes(hashId)]);
//
//  Future&lt;List&lt;String&gt;&gt; hkeys(String hashId) =&gt; connection.sendExpectMultiData([RedisCommand.HKEYS, _keyBytes(hashId)]).then((bytes) =&gt; bytes.map((x) =&gt; new String.fromCharCodes(x)));
//
//  /// Wrapper for [RawRedisCommands.hvals].
//  Future&lt;List&lt;Object&gt;&gt; hvals(String hashId) =&gt; raw.hvals(hashId).then((x) =&gt; x.map(serializer.deserialize));
//
//  /// Wrapper for [RawRedisCommands.hgetall].
//  Future&lt;Map&lt;String,Object&gt;&gt; hgetall(String hashId) =&gt; raw.hgetall(hashId).then(toMap);
//


}
</pre>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="connect">
<button class="show-code">Code</button>
Future&lt;<a href="../redis_client/RedisClient.html">RedisClient</a>&gt; <strong>connect</strong>([String connectionString]) <a class="anchor-link" href="#connect"
              title="Permalink to RedisClient.connect">#</a></h4>
<div class="doc">
<p>Returns a <code>Future</code> for a <a class="crossref" href="../redis_client/RedisClient.html">RedisClient</a>.</p>
<pre class="source">
static Future&lt;RedisClient&gt; connect([ String connectionString ]) {
 var redisClient = new RedisClient._(connectionString);
 return redisClient.connectionFuture.then((_) =&gt; redisClient);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="connection">
<button class="show-code">Code</button>
<a href="../redis_client/RedisConnection.html">RedisConnection</a>         <strong>connection</strong> <a class="anchor-link"
            href="#connection"
            title="Permalink to RedisClient.connection">#</a>
        </h4>
        <div class="doc">
<p>The <a class="crossref" href="../redis_client/RedisConnection.html">RedisConnection</a> used to communicate with the Redis server.</p>
<pre class="source">
RedisConnection connection
</pre>
</div>
</div>
<div class="field"><h4 id="connectionFuture">
<button class="show-code">Code</button>
Future&lt;<a href="../redis_client/RedisConnection.html">RedisConnection</a>&gt;         <strong>connectionFuture</strong> <a class="anchor-link"
            href="#connectionFuture"
            title="Permalink to RedisClient.connectionFuture">#</a>
        </h4>
        <div class="doc">
<p>The future that gets resolved as soon as the connection is available.</p>
<pre class="source">
Future&lt;RedisConnection&gt; connectionFuture
</pre>
</div>
</div>
<div class="field"><h4 id="connectionString">
<button class="show-code">Code</button>
String         <strong>connectionString</strong> <a class="anchor-link"
            href="#connectionString"
            title="Permalink to RedisClient.connectionString">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String connectionString
</pre>
</div>
</div>
<div class="field"><h4 id="db">
<button class="show-code">Code</button>
final int         <strong>db</strong> <a class="anchor-link"
            href="#db"
            title="Permalink to RedisClient.db">#</a>
        </h4>
        <div class="doc">
<p>Wrapper for <a class="crossref" href="../redis_client/RedisConnection.html#db">RedisConnection.db</a></p>
<pre class="source">
int get db =&gt; connection.db;
</pre>
</div>
</div>
<div class="field"><h4 id="dbsize">
<button class="show-code">Code</button>
final Future&lt;int&gt;         <strong>dbsize</strong> <a class="anchor-link"
            href="#dbsize"
            title="Permalink to RedisClient.dbsize">#</a>
        </h4>
        <div class="doc">
<p>Return the number of keys in the currently-selected database.</p>
<pre class="source">
Future&lt;int&gt; get dbsize =&gt; connection.rawSend([ RedisCommand.DBSIZE ]).receiveInteger();
</pre>
</div>
</div>
<div class="field"><h4 id="info">
<button class="show-code">Code</button>
final Future&lt;Map&lt;String, Map&lt;String, String&gt;&gt;&gt;         <strong>info</strong> <a class="anchor-link"
            href="#info"
            title="Permalink to RedisClient.info">#</a>
        </h4>
        <div class="doc">
<p>The INFO command returns information and statistics about the server.</p>
<p>This function parses the output properly and returns a map in the form of:</p>
<pre><code>{
  "Server": {
      "redis_version": "2.5.13",
      "redis_git_sha1": "2812b945"
      /* etc... */
  },
  "Clients": {
      "connected_clients": "8"
      /* etc... */
  }
  /* etc... */
}
</code></pre>
<p>Please refer to the <a href="http://redis.io/commands/info">official redis info documentation</a>
for an explanation of the values.</p>
<pre class="source">
Future&lt;Map&lt;String, Map&lt;String, String&gt;&gt;&gt; get info {
 return connection.rawSend([ RedisCommand.INFO ]).receiveBulkString().then(parseInfoString);
}
</pre>
</div>
</div>
<div class="field"><h4 id="lastsave">
<button class="show-code">Code</button>
final Future&lt;DateTime&gt;         <strong>lastsave</strong> <a class="anchor-link"
            href="#lastsave"
            title="Permalink to RedisClient.lastsave">#</a>
        </h4>
        <div class="doc">
<p>Returns the DateTime of the last DB <a class="crossref" href="../redis_client/RedisClient.html#save">save</a> executed with success.</p>
<pre class="source">
Future&lt;DateTime&gt; get lastsave =&gt; connection.rawSend([ RedisCommand.LASTSAVE ]).receiveInteger().then((int unixTs) =&gt; new DateTime.fromMillisecondsSinceEpoch(unixTs * 1000, isUtc: true));
</pre>
</div>
</div>
<div class="field"><h4 id="serializer">
<button class="show-code">Code</button>
<a href="../redis_client/RedisSerializer.html">RedisSerializer</a>         <strong>serializer</strong> <a class="anchor-link"
            href="#serializer"
            title="Permalink to RedisClient.serializer">#</a>
        </h4>
        <div class="doc">
<p>Used to serialize and deserialize the values stored inside Redis.</p>
<pre class="source">
RedisSerializer serializer = new RedisSerializer()
</pre>
</div>
</div>
<div class="field"><h4 id="stats">
<button class="show-code">Code</button>
final Map         <strong>stats</strong> <a class="anchor-link"
            href="#stats"
            title="Permalink to RedisClient.stats">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Map get stats =&gt; connection.stats;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="bgrewriteaof">
<button class="show-code">Code</button>
Future <strong>bgrewriteaof</strong>() <a class="anchor-link" href="#bgrewriteaof"
              title="Permalink to RedisClient.bgrewriteaof">#</a></h4>
<div class="doc">
<p>Instruct Redis to start an Append Only File rewrite process. The rewrite will
create a small optimized version of the current Append Only File.</p>
<p>If BGREWRITEAOF fails, no data gets lost as the old AOF will be untouched.</p>
<p>The rewrite will be only triggered by Redis if there is not already a background
process doing persistence.</p>
<pre class="source">
Future bgrewriteaof() =&gt; connection.rawSend([ RedisCommand.BGREWRITEAOF ]).receiveStatus("OK");
</pre>
</div>
</div>
<div class="method"><h4 id="bgsave">
<button class="show-code">Code</button>
Future <strong>bgsave</strong>() <a class="anchor-link" href="#bgsave"
              title="Permalink to RedisClient.bgsave">#</a></h4>
<div class="doc">
<p>Save the DB in background. The OK code is immediately returned.</p>
<p>Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits.</p>
<p>A client my be able to check if the operation succeeded using the <a class="crossref" href="../redis_client/RedisClient.html#lastsave">lastsave</a> command.</p>
<pre class="source">
Future bgsave() =&gt; connection.rawSend([ RedisCommand.BGSAVE ]).receiveStatus("Background saving started");
</pre>
</div>
</div>
<div class="method"><h4 id="close">
<button class="show-code">Code</button>
Future <strong>close</strong>() <a class="anchor-link" href="#close"
              title="Permalink to RedisClient.close">#</a></h4>
<div class="doc">
<pre class="source">
Future close() =&gt; connection.close();
</pre>
</div>
</div>
<div class="method"><h4 id="del">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>del</strong>(String key) <a class="anchor-link" href="#del"
              title="Permalink to RedisClient.del">#</a></h4>
<div class="doc">
<p>Deletes a single key.</p>
<p>Returns true if the key existed, false otherwise.</p>
<p>Contrary to redis <code>DEL</code> command this method takes only one key for
convenience. Use <a class="crossref" href="../redis_client/RedisClient.html#mdel">mdel</a> if you want to delete multiple keys.</p>
<pre class="source">
Future&lt;bool&gt; del(String key) =&gt; mdel([ key ]).then((deleteCount) =&gt; deleteCount == 1);
</pre>
</div>
</div>
<div class="method"><h4 id="echo">
<button class="show-code">Code</button>
Future&lt;Object&gt; <strong>echo</strong>(Object value) <a class="anchor-link" href="#echo"
              title="Permalink to RedisClient.echo">#</a></h4>
<div class="doc">
<p>Returns message.</p>
<pre class="source">
Future&lt;Object&gt; echo(Object value) =&gt; connection.rawSend([ RedisCommand.ECHO, serializer.serialize(value) ]).receiveBulkData().then(serializer.deserialize);
</pre>
</div>
</div>
<div class="method"><h4 id="exists">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>exists</strong>(String key) <a class="anchor-link" href="#exists"
              title="Permalink to RedisClient.exists">#</a></h4>
<div class="doc">
<p>Returns <code>true</code> if key exists, <code>false</code> otherwise.</p>
<pre class="source">
Future&lt;bool&gt; exists(String key) =&gt; connection.rawSend([ RedisCommand.EXISTS, _keyBytes(key) ]).receiveBool();
</pre>
</div>
</div>
<div class="method"><h4 id="flushall">
<button class="show-code">Code</button>
Future <strong>flushall</strong>() <a class="anchor-link" href="#flushall"
              title="Permalink to RedisClient.flushall">#</a></h4>
<div class="doc">
<p>Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.</p>
<pre class="source">
Future flushall() =&gt; connection.rawSend([ RedisCommand.FLUSHALL ]).receiveStatus("OK");
</pre>
</div>
</div>
<div class="method"><h4 id="flushdb">
<button class="show-code">Code</button>
Future <strong>flushdb</strong>() <a class="anchor-link" href="#flushdb"
              title="Permalink to RedisClient.flushdb">#</a></h4>
<div class="doc">
<p>Delete all the keys of the currently selected DB. This command never fails</p>
<pre class="source">
Future flushdb() =&gt; connection.rawSend([ RedisCommand.FLUSHDB ]).receiveStatus("OK");
</pre>
</div>
</div>
<div class="method"><h4 id="get">
<button class="show-code">Code</button>
Future&lt;Object&gt; <strong>get</strong>(String key) <a class="anchor-link" href="#get"
              title="Permalink to RedisClient.get">#</a></h4>
<div class="doc">
<p>Returns the stored value of given key.</p>
<pre class="source">
Future&lt;Object&gt; get(String key) =&gt; connection.rawSend([ RedisCommand.GET, _keyBytes(key) ]).receiveBulkDeserialized(serializer);
</pre>
</div>
</div>
<div class="method"><h4 id="getset">
<button class="show-code">Code</button>
Future&lt;Object&gt; <strong>getset</strong>(String key, Object value) <a class="anchor-link" href="#getset"
              title="Permalink to RedisClient.getset">#</a></h4>
<div class="doc">
<p>Sets the value of given key, and returns the value that was stored previously.</p>
<pre class="source">
Future&lt;Object&gt; getset(String key, Object value) =&gt; connection.rawSend([RedisCommand.GETSET, _keyBytes(key), serializer.serialize(value)]).receiveBulkData().then(serializer.deserialize);
</pre>
</div>
</div>
<div class="method"><h4 id="incr">
<button class="show-code">Code</button>
Future&lt;int&gt; <strong>incr</strong>(String key) <a class="anchor-link" href="#incr"
              title="Permalink to RedisClient.incr">#</a></h4>
<div class="doc">
<p>Increments the number stored at key by one returning the value of key after
the increment.</p>
<p>If the key does not exist, it is set to 0 before performing the operation.</p>
<p>An error is returned if the key contains a value of the wrong type or
contains a string that can not be represented as integer.</p>
<p>This operation is limited to 64 bit signed integers.</p>
<pre class="source">
Future&lt;int&gt; incr(String key) =&gt; connection.rawSend([ RedisCommand.INCR, _keyBytes(key) ]).receiveInteger();
</pre>
</div>
</div>
<div class="method"><h4 id="incrby">
<button class="show-code">Code</button>
Future&lt;int&gt; <strong>incrby</strong>(String key, int count) <a class="anchor-link" href="#incrby"
              title="Permalink to RedisClient.incrby">#</a></h4>
<div class="doc">
<p>Increments the number stored at key by increment and returns the value after
the increment.</p>
<p>If the key does not exist, it is set to 0 before performing the operation.</p>
<p>An error is returned if the key contains a value of the wrong type or
contains a string that can not be represented as integer.</p>
<p>This operation is limited to 64 bit signed integers.</p>
<pre class="source">
Future&lt;int&gt; incrby(String key, int count) =&gt; connection.rawSend([ RedisCommand.INCRBY, _keyBytes(key), serializer.serialize(count) ]).receiveInteger();
</pre>
</div>
</div>
<div class="method"><h4 id="keys">
<button class="show-code">Code</button>
Future&lt;List&lt;String&gt;&gt; <strong>keys</strong>(String pattern) <a class="anchor-link" href="#keys"
              title="Permalink to RedisClient.keys">#</a></h4>
<div class="doc">
<h1>Keys</h1>
<p>Returns all keys matching pattern.</p>
<p>While the time complexity for this operation is O(N), the constant times are fairly low. For example, Redis running on an entry level laptop can scan a 1 million key database in 40 milliseconds.</p>
<p>Supported glob-style patterns:</p><ul><li><code>h?llo</code> matches <code>hello</code>, <code>hallo</code> and <code>hxllo</code></li><li><code>h*llo</code> matches <code>hllo</code> and <code>heeeello</code></li><li><code>h[ae]llo</code> matches <code>hello</code> and <code>hallo</code>, but not <code>hillo</code></li></ul>
<p>Use <code>\</code> to escape special characters if you want to match them verbatim.</p>
<p><strong>Warning</strong>: consider <a class="crossref" href="../redis_client/RedisClient.html#keys">keys</a> as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don't use <a class="crossref" href="../redis_client/RedisClient.html#keys">keys</a> in your regular application code. If you're looking for a way to find keys in a subset of your keyspace, consider using sets.</p>
<pre class="source">
Future&lt;List&lt;String&gt;&gt; keys(String pattern) =&gt; connection.rawSend([ RedisCommand.KEYS, _keyBytes(pattern) ]).receiveMultiBulkStrings();
</pre>
</div>
</div>
<div class="method"><h4 id="mdel">
<button class="show-code">Code</button>
Future&lt;int&gt; <strong>mdel</strong>(List&lt;String&gt; keys) <a class="anchor-link" href="#mdel"
              title="Permalink to RedisClient.mdel">#</a></h4>
<div class="doc">
<p>Deletes multiple keys and returns the number of deleted keys.</p>
<p>This command is called <code>DEL</code> in redis.</p>
<pre class="source">
Future&lt;int&gt; mdel(List&lt;String&gt; keys) =&gt; keys.isEmpty ? new Future.value(0) : connection.rawSend(_CommandUtils.mergeCommandWithStringArgs(RedisCommand.DEL, keys)).receiveInteger();
</pre>
</div>
</div>
<div class="method"><h4 id="mget">
<button class="show-code">Code</button>
Future&lt;List&lt;Object&gt;&gt; <strong>mget</strong>(List&lt;String&gt; keys) <a class="anchor-link" href="#mget"
              title="Permalink to RedisClient.mget">#</a></h4>
<div class="doc">
<p>Returns all the stored values of given keys.</p>
<pre class="source">
Future&lt;List&lt;Object&gt;&gt; mget(List&lt;String&gt; keys) =&gt; keys.isEmpty ? new Future.value([ ]) : connection.rawSend(_CommandUtils.mergeCommandWithStringArgs(RedisCommand.MGET, keys)).receiveMultiBulkDeserialized(serializer);
</pre>
</div>
</div>
<div class="method"><h4 id="mset">
<button class="show-code">Code</button>
Future <strong>mset</strong>(Map map) <a class="anchor-link" href="#mset"
              title="Permalink to RedisClient.mset">#</a></h4>
<div class="doc">
<p>Sets all values in the given map.</p>
<p><a class="crossref" href="../redis_client/RedisClient.html#mset">mset</a> replaces existing values with new values, just as regular <a class="crossref" href="../redis_client/RedisClient.html#set">set</a>.</p>
<p>See <a class="crossref" href="../redis_client/RedisClient.html#msetnx">msetnx</a> if you don't want to overwrite existing values.</p>
<pre class="source">
Future mset(Map map) =&gt; connection.rawSend(_keyValueMapToList(RedisCommand.MSET, map)).receiveStatus("OK");
</pre>
</div>
</div>
<div class="method"><h4 id="msetnx">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>msetnx</strong>(Map map) <a class="anchor-link" href="#msetnx"
              title="Permalink to RedisClient.msetnx">#</a></h4>
<div class="doc">
<p>Sets the given keys to their respective values. <strong><a class="crossref" href="../redis_client/RedisClient.html#msetnx">msetnx</a> will not perform any operation at all even if just a single key already exists.</strong></p>
<p>Because of this semantic <a class="crossref" href="../redis_client/RedisClient.html#msetnx">msetnx</a> can be used in order to set different keys representing different fields of an unique logic object in a way that ensures that either all the fields or none at all are set.</p>
<p><a class="crossref" href="../redis_client/RedisClient.html#msetnx">msetnx</a> is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</p>
<pre class="source">
Future&lt;bool&gt; msetnx(Map map) =&gt; connection.rawSend(_keyValueMapToList(RedisCommand.MSETNX, map)).receiveBool();
</pre>
</div>
</div>
<div class="method"><h4 id="parseInfoString">
<button class="show-code">Code</button>
Map&lt;String, Map&lt;String, String&gt;&gt; <strong>parseInfoString</strong>(String lines) <a class="anchor-link" href="#parseInfoString"
              title="Permalink to RedisClient.parseInfoString">#</a></h4>
<div class="doc">
<p>Parses the string returned by the INFO command.</p>
<pre class="source">
Map&lt;String, Map&lt;String, String&gt;&gt; parseInfoString(String lines) {
 Map&lt;String, Map&lt;String, String&gt;&gt; info = { };

 var sectionMap, sectionName;

 for (String line in lines.split(new RegExp(r"(\r\n|\n)"))) {
   if (line.isEmpty) continue;

   if (line.substring(0, 2) == '# ') {
     // New section
     sectionName = line.substring(2);
     sectionMap = new Map&lt;String, String&gt;();
     info[sectionName] = sectionMap;
   }
   else {
     if (sectionMap == null) throw new RedisClientException("Received an info line ($line) without a section.");

     // Section info
     var colonIndex = line.indexOf(":");
     if (colonIndex &lt; 1) throw new RedisClientException("The info line did not contain a colon (:).");

     sectionMap[line.substring(0, colonIndex)] = line.substring(colonIndex + 1);
   }
 }

 return info;
}
</pre>
</div>
</div>
<div class="method"><h4 id="persist">
<button class="show-code">Code</button>
Future&lt;bool&gt; <strong>persist</strong>(String key) <a class="anchor-link" href="#persist"
              title="Permalink to RedisClient.persist">#</a></h4>
<div class="doc">
<p>Remove the existing timeout on key.</p>
<p>Turns the key from volatile (a key with an expire set) to persistent (a key that will never expire as no timeout is associated).</p>
<p>Returns <code>true</code> if the timeout was removed, <code>0</code> if key does not exist or does not have an associated timeout.</p>
<pre class="source">
Future&lt;bool&gt; persist(String key) =&gt; connection.rawSend([ RedisCommand.PERSIST, _keyBytes(key) ]).receiveBool();
</pre>
</div>
</div>
<div class="method"><h4 id="ping">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>ping</strong>() <a class="anchor-link" href="#ping"
              title="Permalink to RedisClient.ping">#</a></h4>
<div class="doc">
<p>This command is often used to test if a connection is still alive, or to measure latency.</p>
<p>Fails if the result is not PONG.</p>
<pre class="source">
Future&lt;String&gt; ping() =&gt; connection.rawSend([ RedisCommand.PING ]).receiveStatus("PONG");
</pre>
</div>
</div>
<div class="method"><h4 id="psetex">
<button class="show-code">Code</button>
Future <strong>psetex</strong>(String key, int expireInMs, Object value) <a class="anchor-link" href="#psetex"
              title="Permalink to RedisClient.psetex">#</a></h4>
<div class="doc">
<p><a class="crossref" href="../redis_client/RedisClient.html#psetex">psetex</a> works exactly like <a class="crossref" href="../redis_client/RedisClient.html#setex">setex</a> with the sole difference that the expire time is specified in milliseconds instead of seconds.</p>
<pre class="source">
Future psetex(String key, int expireInMs, Object value) =&gt; connection.rawSend([ RedisCommand.PSETEX, _keyBytes(key), _intToBytes(expireInMs), serializer.serialize(value) ]).receiveStatus("OK");
</pre>
</div>
</div>
<div class="method"><h4 id="quit">
<button class="show-code">Code</button>
Future <strong>quit</strong>() <a class="anchor-link" href="#quit"
              title="Permalink to RedisClient.quit">#</a></h4>
<div class="doc">
<p>Ask the server to close the connection.</p>
<p>The connection is closed as soon as all pending replies have been written to the client.</p>
<pre class="source">
Future quit() =&gt; connection.rawSend([ RedisCommand.QUIT ]).receiveStatus("OK");
</pre>
</div>
</div>
<div class="method"><h4 id="save">
<button class="show-code">Code</button>
Future <strong>save</strong>() <a class="anchor-link" href="#save"
              title="Permalink to RedisClient.save">#</a></h4>
<div class="doc">
<p>The <a class="crossref" href="../redis_client/RedisClient.html#save">save</a> command performs a synchronous save of the dataset producing a point
in time snapshot of all the data inside the Redis instance, in the form of an RDB file.</p>
<p>You almost never want to call <a class="crossref" href="../redis_client/RedisClient.html#save">save</a> in production environments where it will
block all the other clients. Instead usually <a class="crossref" href="../redis_client/RedisClient.html#bgsave">bgsave</a> is used. However in case
of issues preventing Redis to create the background saving child (for instance
errors in the fork(2) system call), the <a class="crossref" href="../redis_client/RedisClient.html#save">save</a> command can be a good last resort
to perform the dump of the latest dataset.</p>
<pre class="source">
Future save() =&gt; connection.rawSend([ RedisCommand.SAVE ]).receiveStatus("OK");
</pre>
</div>
</div>
<div class="method"><h4 id="select">
<button class="show-code">Code</button>
Future <strong>select</strong>(int db) <a class="anchor-link" href="#select"
              title="Permalink to RedisClient.select">#</a></h4>
<div class="doc">
<h1>Admin</h1>
<p>Select a database.</p>
<p>Wrapper for <a class="crossref" href="../redis_client/RedisConnection.html#select">RedisConnection.select</a></p>
<pre class="source">
Future select(int db) =&gt; connection.select(db);
</pre>
</div>
</div>
<div class="method"><h4 id="set">
<button class="show-code">Code</button>
Future <strong>set</strong>(String key, Object value) <a class="anchor-link" href="#set"
              title="Permalink to RedisClient.set">#</a></h4>
<div class="doc">
<p>Sets the value of given key.</p>
<pre class="source">
Future set(String key, Object value) =&gt; connection.rawSend([ RedisCommand.SET, _keyBytes(key), serializer.serialize(value) ]).receiveStatus("OK");
</pre>
</div>
</div>
<div class="method"><h4 id="setex">
<button class="show-code">Code</button>
Future <strong>setex</strong>(String key, int expireInSecs, Object value) <a class="anchor-link" href="#setex"
              title="Permalink to RedisClient.setex">#</a></h4>
<div class="doc">
<p>Sets a value and the expiration in one step.</p>
<p>This is the same as:</p>
<pre><code>client
    ..set(mykey, value)
    ..expire(mykey, seconds);
</code></pre>
<pre class="source">
Future setex(String key, int expireInSecs, Object value) =&gt; connection.rawSend([ RedisCommand.SETEX, _keyBytes(key), _intToBytes(expireInSecs), serializer.serialize(value) ]).receiveStatus("OK");
</pre>
</div>
</div>
<div class="method"><h4 id="shutdown">
<button class="show-code">Code</button>
Future <strong>shutdown</strong>() <a class="anchor-link" href="#shutdown"
              title="Permalink to RedisClient.shutdown">#</a></h4>
<div class="doc">
<p>The command behavior is the following:</p><ul><li>Stop all the clients.</li><li>Perform a blocking SAVE if at least one <strong>save point</strong> is configured.</li><li>Flush the Append Only File if AOF is enabled.</li><li>Quit the server.</li></ul>
<p>If persistence is enabled this commands makes sure that Redis is switched off
without the lost of any data. This is not guaranteed if the client uses simply
SAVE and then QUIT because other clients may alter the DB data between the two commands.</p>
<p>Note: A Redis instance that is configured for not persisting on disk (no AOF
configured, nor "save" directive) will not dump the RDB file on SHUTDOWN,
as usually you don't want Redis instances used only for caching to block on
when shutting down.</p>
<pre class="source">
Future shutdown() =&gt; connection.rawSend([ RedisCommand.SHUTDOWN ]).receive();
</pre>
</div>
</div>
<div class="method"><h4 id="toMap">
<button class="show-code">Code</button>
Map&lt;String, Object&gt; <strong>toMap</strong>(List&lt;List&lt;int&gt;&gt; multiData) <a class="anchor-link" href="#toMap"
              title="Permalink to RedisClient.toMap">#</a></h4>
<div class="doc">
<p>Converts bytes to a Map</p>
<pre class="source">
Map&lt;String,Object&gt; toMap(List&lt;List&lt;int&gt;&gt; multiData) {
 Map&lt;String,Object&gt; map = new Map&lt;String,Object&gt;();
 for (int i = 0; i &lt; multiData.length; i += 2) {
   String key = _toStr(multiData[i]);
   map[key] = serializer.deserialize(multiData[i + 1]);
 }
 return map;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toScoreMap">
<button class="show-code">Code</button>
Map&lt;Object, double&gt; <strong>toScoreMap</strong>(List&lt;List&lt;int&gt;&gt; multiData) <a class="anchor-link" href="#toScoreMap"
              title="Permalink to RedisClient.toScoreMap">#</a></h4>
<div class="doc">
<pre class="source">
Map&lt;Object,double&gt; toScoreMap(List&lt;List&lt;int&gt;&gt; multiData) {
 Map&lt;Object,double&gt; map = new Map&lt;String,double&gt;();
 for (int i = 0; i &lt; multiData.length; i += 2) {
   Object key = serializer.deserialize(multiData[i]);
   map[key] = double.parse(_toStr(multiData[i + 1]));
 }
 return map;
}
</pre>
</div>
</div>
<div class="method"><h4 id="ttl">
<button class="show-code">Code</button>
Future&lt;int&gt; <strong>ttl</strong>(String key) <a class="anchor-link" href="#ttl"
              title="Permalink to RedisClient.ttl">#</a></h4>
<div class="doc">
<p>Returns the remaining time to live of a key that has a timeout.</p>
<p>This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.</p>
<pre class="source">
Future&lt;int&gt; ttl(String key) =&gt; connection.rawSend([ RedisCommand.TTL, _keyBytes(key) ]).receiveInteger();
</pre>
</div>
</div>
<div class="method"><h4 id="type">
<button class="show-code">Code</button>
Future&lt;String&gt; <strong>type</strong>(String key) <a class="anchor-link" href="#type"
              title="Permalink to RedisClient.type">#</a></h4>
<div class="doc">
<p>Returns the string representation of the type of the value stored at key.</p>
<p>The different types that can be returned are:</p><ul><li>string</li><li>list</li><li>set</li><li>zset</li><li>hash</li><li>none if string didn't exist</li></ul>
<pre class="source">
Future&lt;String&gt; type(String key) =&gt; connection.rawSend([ RedisCommand.TYPE, _keyBytes(key) ]).receiveStatus();
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-06-10 23:35:58.413</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
